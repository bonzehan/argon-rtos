/*
 * Copyright (c) 2013, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_MCG_REGISTERS_H__
#define __HW_MCG_REGISTERS_H__

#include "regs.h"

/*
 * MKL25Z4 MCG
 *
 * Multipurpose Clock Generator module
 *
 * Registers defined in this header file:
 * - HW_MCG_C1 - MCG Control 1 Register
 * - HW_MCG_C2 - MCG Control 2 Register
 * - HW_MCG_C3 - MCG Control 3 Register
 * - HW_MCG_C4 - MCG Control 4 Register
 * - HW_MCG_C5 - MCG Control 5 Register
 * - HW_MCG_C6 - MCG Control 6 Register
 * - HW_MCG_S - MCG Status Register
 * - HW_MCG_ATC - MCG Auto Trim Control Register
 * - HW_MCG_ATCVH - MCG Auto Trim Compare Value High Register
 * - HW_MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 * - HW_MCG_C7 - MCG Control 7 Register
 * - HW_MCG_C8 - MCG Control 8 Register
 * - HW_MCG_C9 - MCG Control 9 Register
 *
 * - hw_mcg_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_MCG_BASE
#define HW_MCG_INSTANCE_COUNT (1U) //!< Number of instances of the MCG module.
#define REGS_MCG_BASE (0x40064000U) //!< Base address for MCG.
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_C1 - MCG Control 1 Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_C1 - MCG Control 1 Register (RW)
 *
 * Reset value: 0x04U
 */
typedef union _hw_mcg_c1
{
    uint8_t U;
    struct _hw_mcg_c1_bitfields
    {
        uint8_t IREFSTEN : 1; //!< [0] Internal Reference Stop Enable
        uint8_t IRCLKEN : 1; //!< [1] Internal Reference Clock Enable
        uint8_t IREFS : 1; //!< [2] Internal Reference Select
        uint8_t FRDIV : 3; //!< [5:3] FLL External Reference Divider
        uint8_t CLKS : 2; //!< [7:6] Clock Source Select
    } B;
} hw_mcg_c1_t;
#endif

/*!
 * @name Constants and macros for entire MCG_C1 register
 */
//@{
#define HW_MCG_C1_ADDR      (REGS_MCG_BASE + 0x0U)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_C1           (*(__IO hw_mcg_c1_t *) HW_MCG_C1_ADDR)
#define HW_MCG_C1_RD()      (HW_MCG_C1.U)
#define HW_MCG_C1_WR(v)     (HW_MCG_C1.U = (v))
#define HW_MCG_C1_SET(v)    (BME_OR8(HW_MCG_C1_ADDR, (uint8_t)(v)))
#define HW_MCG_C1_CLR(v)    (BME_AND8(HW_MCG_C1_ADDR, (uint8_t)(~(v))))
#define HW_MCG_C1_TOG(v)    (BME_XOR8(HW_MCG_C1_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_C1 bitfields
 */

/*! @name Register MCG_C1, field IREFSTEN[0] (RW)
 *
 * Controls whether or not the internal reference clock remains enabled when the MCG enters Stop
 * mode.
 *
 * Values:
 * - 0 - Internal reference clock is disabled in Stop mode.
 * - 1 - Internal reference clock is enabled in Stop mode if IRCLKEN is set or if MCG is in FEI, FBI, or BLPI
 *     modes before entering Stop mode.
 */
//@{
#define BP_MCG_C1_IREFSTEN      (0U)      //!< Bit position for MCG_C1_IREFSTEN.
#define BM_MCG_C1_IREFSTEN      (0x01U)  //!< Bit mask for MCG_C1_IREFSTEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C1_IREFSTEN field.
#define BR_MCG_C1_IREFSTEN(v)   (BME_UBFX8(HW_MCG_C1_ADDR, BP_MCG_C1_IREFSTEN, 1))
#endif

//! @brief Format value for bitfield MCG_C1_IREFSTEN.
#define BF_MCG_C1_IREFSTEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C1_IREFSTEN), uint8_t) & BM_MCG_C1_IREFSTEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IREFSTEN field to a new value.
#define BW_MCG_C1_IREFSTEN(v)   (BME_BFI8(HW_MCG_C1_ADDR, ((uint8_t)(v) << BP_MCG_C1_IREFSTEN), BP_MCG_C1_IREFSTEN, 1))
#endif
//@}

/*! @name Register MCG_C1, field IRCLKEN[1] (RW)
 *
 * Enables the internal reference clock for use as MCGIRCLK.
 *
 * Values:
 * - 0 - MCGIRCLK inactive.
 * - 1 - MCGIRCLK active.
 */
//@{
#define BP_MCG_C1_IRCLKEN      (1U)      //!< Bit position for MCG_C1_IRCLKEN.
#define BM_MCG_C1_IRCLKEN      (0x02U)  //!< Bit mask for MCG_C1_IRCLKEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C1_IRCLKEN field.
#define BR_MCG_C1_IRCLKEN(v)   (BME_UBFX8(HW_MCG_C1_ADDR, BP_MCG_C1_IRCLKEN, 1))
#endif

//! @brief Format value for bitfield MCG_C1_IRCLKEN.
#define BF_MCG_C1_IRCLKEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C1_IRCLKEN), uint8_t) & BM_MCG_C1_IRCLKEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IRCLKEN field to a new value.
#define BW_MCG_C1_IRCLKEN(v)   (BME_BFI8(HW_MCG_C1_ADDR, ((uint8_t)(v) << BP_MCG_C1_IRCLKEN), BP_MCG_C1_IRCLKEN, 1))
#endif
//@}

/*! @name Register MCG_C1, field IREFS[2] (RW)
 *
 * Selects the reference clock source for the FLL.
 *
 * Values:
 * - 0 - External reference clock is selected.
 * - 1 - The slow internal reference clock is selected.
 */
//@{
#define BP_MCG_C1_IREFS      (2U)      //!< Bit position for MCG_C1_IREFS.
#define BM_MCG_C1_IREFS      (0x04U)  //!< Bit mask for MCG_C1_IREFS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C1_IREFS field.
#define BR_MCG_C1_IREFS(v)   (BME_UBFX8(HW_MCG_C1_ADDR, BP_MCG_C1_IREFS, 1))
#endif

//! @brief Format value for bitfield MCG_C1_IREFS.
#define BF_MCG_C1_IREFS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C1_IREFS), uint8_t) & BM_MCG_C1_IREFS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IREFS field to a new value.
#define BW_MCG_C1_IREFS(v)   (BME_BFI8(HW_MCG_C1_ADDR, ((uint8_t)(v) << BP_MCG_C1_IREFS), BP_MCG_C1_IREFS, 1))
#endif
//@}

/*! @name Register MCG_C1, field FRDIV[5:3] (RW)
 *
 * Selects the amount to divide down the external reference clock for the FLL. The resulting
 * frequency must be in the range 31.25 kHz to 39.0625 kHz (This is required when FLL/DCO is the
 * clock source for MCGOUTCLK . In FBE mode, it is not required to meet this range, but it is
 * recommended in the cases when trying to enter a FLL mode from FBE).
 *
 * Values:
 * - 000 - If RANGE = 0 , Divide Factor is 1; for all other RANGE values, Divide Factor is 32.
 * - 001 - If RANGE = 0 , Divide Factor is 2; for all other RANGE values, Divide Factor is 64.
 * - 010 - If RANGE = 0 , Divide Factor is 4; for all other RANGE values, Divide Factor is 128.
 * - 011 - If RANGE = 0 , Divide Factor is 8; for all other RANGE values, Divide Factor is 256.
 * - 100 - If RANGE = 0 , Divide Factor is 16; for all other RANGE values, Divide Factor is 512.
 * - 101 - If RANGE = 0 , Divide Factor is 32; for all other RANGE values, Divide Factor is 1024.
 * - 110 - If RANGE = 0 , Divide Factor is 64; for all other RANGE values, Divide Factor is 1280 .
 * - 111 - If RANGE = 0 , Divide Factor is 128; for all other RANGE values, Divide Factor is 1536 .
 */
//@{
#define BP_MCG_C1_FRDIV      (3U)      //!< Bit position for MCG_C1_FRDIV.
#define BM_MCG_C1_FRDIV      (0x38U)  //!< Bit mask for MCG_C1_FRDIV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C1_FRDIV field.
#define BR_MCG_C1_FRDIV(v)   (BME_UBFX8(HW_MCG_C1_ADDR, BP_MCG_C1_FRDIV, 3))
#endif

//! @brief Format value for bitfield MCG_C1_FRDIV.
#define BF_MCG_C1_FRDIV(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C1_FRDIV), uint8_t) & BM_MCG_C1_FRDIV)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FRDIV field to a new value.
#define BW_MCG_C1_FRDIV(v)   (BME_BFI8(HW_MCG_C1_ADDR, ((uint8_t)(v) << BP_MCG_C1_FRDIV), BP_MCG_C1_FRDIV, 3))
#endif
//@}

/*! @name Register MCG_C1, field CLKS[7:6] (RW)
 *
 * Selects the clock source for MCGOUTCLK .
 *
 * Values:
 * - 00 - Encoding 0 — Output of FLL or PLL is selected (depends on PLLS control bit).
 * - 01 - Encoding 1 — Internal reference clock is selected.
 * - 10 - Encoding 2 — External reference clock is selected.
 * - 11 - Encoding 3 — Reserved.
 */
//@{
#define BP_MCG_C1_CLKS      (6U)      //!< Bit position for MCG_C1_CLKS.
#define BM_MCG_C1_CLKS      (0xc0U)  //!< Bit mask for MCG_C1_CLKS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C1_CLKS field.
#define BR_MCG_C1_CLKS(v)   (BME_UBFX8(HW_MCG_C1_ADDR, BP_MCG_C1_CLKS, 2))
#endif

//! @brief Format value for bitfield MCG_C1_CLKS.
#define BF_MCG_C1_CLKS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C1_CLKS), uint8_t) & BM_MCG_C1_CLKS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CLKS field to a new value.
#define BW_MCG_C1_CLKS(v)   (BME_BFI8(HW_MCG_C1_ADDR, ((uint8_t)(v) << BP_MCG_C1_CLKS), BP_MCG_C1_CLKS, 2))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_C2 - MCG Control 2 Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_C2 - MCG Control 2 Register (RW)
 *
 * Reset value: 0x80U
 */
typedef union _hw_mcg_c2
{
    uint8_t U;
    struct _hw_mcg_c2_bitfields
    {
        uint8_t IRCS : 1; //!< [0] Internal Reference Clock Select
        uint8_t LP : 1; //!< [1] Low Power Select
        uint8_t EREFS : 1; //!< [2] External Reference Select
        uint8_t HGO : 1; //!< [3] High Gain Oscillator Select
        uint8_t RANGE : 2; //!< [5:4] Frequency Range Select
        uint8_t RESERVED0 : 2; //!< [7:6] Reserved.
    } B;
} hw_mcg_c2_t;
#endif

/*!
 * @name Constants and macros for entire MCG_C2 register
 */
//@{
#define HW_MCG_C2_ADDR      (REGS_MCG_BASE + 0x1U)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_C2           (*(__IO hw_mcg_c2_t *) HW_MCG_C2_ADDR)
#define HW_MCG_C2_RD()      (HW_MCG_C2.U)
#define HW_MCG_C2_WR(v)     (HW_MCG_C2.U = (v))
#define HW_MCG_C2_SET(v)    (BME_OR8(HW_MCG_C2_ADDR, (uint8_t)(v)))
#define HW_MCG_C2_CLR(v)    (BME_AND8(HW_MCG_C2_ADDR, (uint8_t)(~(v))))
#define HW_MCG_C2_TOG(v)    (BME_XOR8(HW_MCG_C2_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_C2 bitfields
 */

/*! @name Register MCG_C2, field IRCS[0] (RW)
 *
 * Selects between the fast or slow internal reference clock source.
 *
 * Values:
 * - 0 - Slow internal reference clock selected.
 * - 1 - Fast internal reference clock selected.
 */
//@{
#define BP_MCG_C2_IRCS      (0U)      //!< Bit position for MCG_C2_IRCS.
#define BM_MCG_C2_IRCS      (0x01U)  //!< Bit mask for MCG_C2_IRCS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C2_IRCS field.
#define BR_MCG_C2_IRCS(v)   (BME_UBFX8(HW_MCG_C2_ADDR, BP_MCG_C2_IRCS, 1))
#endif

//! @brief Format value for bitfield MCG_C2_IRCS.
#define BF_MCG_C2_IRCS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C2_IRCS), uint8_t) & BM_MCG_C2_IRCS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the IRCS field to a new value.
#define BW_MCG_C2_IRCS(v)   (BME_BFI8(HW_MCG_C2_ADDR, ((uint8_t)(v) << BP_MCG_C2_IRCS), BP_MCG_C2_IRCS, 1))
#endif
//@}

/*! @name Register MCG_C2, field LP[1] (RW)
 *
 * Controls whether the FLL or PLL is disabled in BLPI and BLPE modes. In FBE or PBE modes , setting
 * this bit to 1 will transition the MCG into BLPE mode; in FBI mode, setting this bit to 1 will
 * transition the MCG into BLPI mode. In any other MCG mode, LP bit has no affect.
 *
 * Values:
 * - 0 - FLL or PLL is not disabled in bypass modes.
 * - 1 - FLL or PLL is disabled in bypass modes (lower power)
 */
//@{
#define BP_MCG_C2_LP      (1U)      //!< Bit position for MCG_C2_LP.
#define BM_MCG_C2_LP      (0x02U)  //!< Bit mask for MCG_C2_LP.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C2_LP field.
#define BR_MCG_C2_LP(v)   (BME_UBFX8(HW_MCG_C2_ADDR, BP_MCG_C2_LP, 1))
#endif

//! @brief Format value for bitfield MCG_C2_LP.
#define BF_MCG_C2_LP(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C2_LP), uint8_t) & BM_MCG_C2_LP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LP field to a new value.
#define BW_MCG_C2_LP(v)   (BME_BFI8(HW_MCG_C2_ADDR, ((uint8_t)(v) << BP_MCG_C2_LP), BP_MCG_C2_LP, 1))
#endif
//@}

/*! @name Register MCG_C2, field EREFS[2] (RW)
 *
 * Selects the source for the external reference clock. See the Oscillator (OSC) chapter for more
 * details.
 *
 * Values:
 * - 0 - External reference clock requested.
 * - 1 - Oscillator requested.
 */
//@{
#define BP_MCG_C2_EREFS      (2U)      //!< Bit position for MCG_C2_EREFS.
#define BM_MCG_C2_EREFS      (0x04U)  //!< Bit mask for MCG_C2_EREFS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C2_EREFS field.
#define BR_MCG_C2_EREFS(v)   (BME_UBFX8(HW_MCG_C2_ADDR, BP_MCG_C2_EREFS, 1))
#endif

//! @brief Format value for bitfield MCG_C2_EREFS.
#define BF_MCG_C2_EREFS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C2_EREFS), uint8_t) & BM_MCG_C2_EREFS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the EREFS field to a new value.
#define BW_MCG_C2_EREFS(v)   (BME_BFI8(HW_MCG_C2_ADDR, ((uint8_t)(v) << BP_MCG_C2_EREFS), BP_MCG_C2_EREFS, 1))
#endif
//@}

/*! @name Register MCG_C2, field HGO[3] (RW)
 *
 * Controls the crystal oscillator mode of operation. See the Oscillator (OSC) chapter for more
 * details.
 *
 * Values:
 * - 0 - Configure crystal oscillator for low-power operation.
 * - 1 - Configure crystal oscillator for high-gain operation.
 */
//@{
#define BP_MCG_C2_HGO      (3U)      //!< Bit position for MCG_C2_HGO.
#define BM_MCG_C2_HGO      (0x08U)  //!< Bit mask for MCG_C2_HGO.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C2_HGO field.
#define BR_MCG_C2_HGO(v)   (BME_UBFX8(HW_MCG_C2_ADDR, BP_MCG_C2_HGO, 1))
#endif

//! @brief Format value for bitfield MCG_C2_HGO.
#define BF_MCG_C2_HGO(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C2_HGO), uint8_t) & BM_MCG_C2_HGO)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HGO field to a new value.
#define BW_MCG_C2_HGO(v)   (BME_BFI8(HW_MCG_C2_ADDR, ((uint8_t)(v) << BP_MCG_C2_HGO), BP_MCG_C2_HGO, 1))
#endif
//@}

/*! @name Register MCG_C2, field RANGE[5:4] (RW)
 *
 * Selects the frequency range for the crystal oscillator or external clock source. See the
 * Oscillator (OSC) chapter for more details and the device data sheet for the frequency ranges
 * used.
 *
 * Values:
 * - 00 - Encoding 0 — Low frequency range selected for the crystal oscillator .
 * - 01 - Encoding 1 — High frequency range selected for the crystal oscillator .
 * - 1X - Encoding 2 — Very high frequency range selected for the crystal oscillator .
 */
//@{
#define BP_MCG_C2_RANGE      (4U)      //!< Bit position for MCG_C2_RANGE.
#define BM_MCG_C2_RANGE      (0x30U)  //!< Bit mask for MCG_C2_RANGE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C2_RANGE field.
#define BR_MCG_C2_RANGE(v)   (BME_UBFX8(HW_MCG_C2_ADDR, BP_MCG_C2_RANGE, 2))
#endif

//! @brief Format value for bitfield MCG_C2_RANGE.
#define BF_MCG_C2_RANGE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C2_RANGE), uint8_t) & BM_MCG_C2_RANGE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the RANGE field to a new value.
#define BW_MCG_C2_RANGE(v)   (BME_BFI8(HW_MCG_C2_ADDR, ((uint8_t)(v) << BP_MCG_C2_RANGE), BP_MCG_C2_RANGE, 2))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_C3 - MCG Control 3 Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_C3 - MCG Control 3 Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_c3
{
    uint8_t U;
    struct _hw_mcg_c3_bitfields
    {
        uint8_t SCTRIM : 8; //!< [7:0] Slow Internal Reference Clock Trim Setting
    } B;
} hw_mcg_c3_t;
#endif

/*!
 * @name Constants and macros for entire MCG_C3 register
 */
//@{
#define HW_MCG_C3_ADDR      (REGS_MCG_BASE + 0x2U)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_C3           (*(__IO hw_mcg_c3_t *) HW_MCG_C3_ADDR)
#define HW_MCG_C3_RD()      (HW_MCG_C3.U)
#define HW_MCG_C3_WR(v)     (HW_MCG_C3.U = (v))
#define HW_MCG_C3_SET(v)    (BME_OR8(HW_MCG_C3_ADDR, (uint8_t)(v)))
#define HW_MCG_C3_CLR(v)    (BME_AND8(HW_MCG_C3_ADDR, (uint8_t)(~(v))))
#define HW_MCG_C3_TOG(v)    (BME_XOR8(HW_MCG_C3_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_C3 bitfields
 */

/*! @name Register MCG_C3, field SCTRIM[7:0] (RW)
 *
 * SCTRIM A value for SCTRIM is loaded during reset from a factory programmed location. controls the
 * slow internal reference clock frequency by controlling the slow internal reference clock period.
 * The SCTRIM bits are binary weighted, that is, bit 1 adjusts twice as much as bit 0. Increasing
 * the binary value increases the period, and decreasing the value decreases the period. An
 * additional fine trim bit is available in C4 register as the SCFTRIM bit. Upon reset, this value
 * is loaded with a factory trim value. If an SCTRIM value stored in nonvolatile memory is to be
 * used, it is your responsibility to copy that value from the nonvolatile memory location to this
 * register.
 */
//@{
#define BP_MCG_C3_SCTRIM      (0U)      //!< Bit position for MCG_C3_SCTRIM.
#define BM_MCG_C3_SCTRIM      (0xffU)  //!< Bit mask for MCG_C3_SCTRIM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C3_SCTRIM field.
#define BR_MCG_C3_SCTRIM(v)   (BME_UBFX8(HW_MCG_C3_ADDR, BP_MCG_C3_SCTRIM, 8))
#endif

//! @brief Format value for bitfield MCG_C3_SCTRIM.
#define BF_MCG_C3_SCTRIM(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C3_SCTRIM), uint8_t) & BM_MCG_C3_SCTRIM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SCTRIM field to a new value.
#define BW_MCG_C3_SCTRIM(v)   (BME_BFI8(HW_MCG_C3_ADDR, ((uint8_t)(v) << BP_MCG_C3_SCTRIM), BP_MCG_C3_SCTRIM, 8))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_C4 - MCG Control 4 Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_C4 - MCG Control 4 Register (RW)
 *
 * Reset value: 0x00U
 *
 * Reset values for DRST and DMX32 bits are 0.
 */
typedef union _hw_mcg_c4
{
    uint8_t U;
    struct _hw_mcg_c4_bitfields
    {
        uint8_t SCFTRIM : 1; //!< [0] Slow Internal Reference Clock Fine Trim
        uint8_t FCTRIM : 4; //!< [4:1] Fast Internal Reference Clock Trim Setting
        uint8_t DRST_DRS : 2; //!< [6:5] DCO Range Select
        uint8_t DMX32 : 1; //!< [7] DCO Maximum Frequency with 32.768 kHz Reference
    } B;
} hw_mcg_c4_t;
#endif

/*!
 * @name Constants and macros for entire MCG_C4 register
 */
//@{
#define HW_MCG_C4_ADDR      (REGS_MCG_BASE + 0x3U)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_C4           (*(__IO hw_mcg_c4_t *) HW_MCG_C4_ADDR)
#define HW_MCG_C4_RD()      (HW_MCG_C4.U)
#define HW_MCG_C4_WR(v)     (HW_MCG_C4.U = (v))
#define HW_MCG_C4_SET(v)    (BME_OR8(HW_MCG_C4_ADDR, (uint8_t)(v)))
#define HW_MCG_C4_CLR(v)    (BME_AND8(HW_MCG_C4_ADDR, (uint8_t)(~(v))))
#define HW_MCG_C4_TOG(v)    (BME_XOR8(HW_MCG_C4_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_C4 bitfields
 */

/*! @name Register MCG_C4, field SCFTRIM[0] (RW)
 *
 * SCFTRIM A value for SCFTRIM is loaded during reset from a factory programmed location . controls
 * the smallest adjustment of the slow internal reference clock frequency. Setting SCFTRIM increases
 * the period and clearing SCFTRIM decreases the period by the smallest amount possible. If an
 * SCFTRIM value stored in nonvolatile memory is to be used, it is your responsibility to copy that
 * value from the nonvolatile memory location to this bit.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_MCG_C4_SCFTRIM      (0U)      //!< Bit position for MCG_C4_SCFTRIM.
#define BM_MCG_C4_SCFTRIM      (0x01U)  //!< Bit mask for MCG_C4_SCFTRIM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C4_SCFTRIM field.
#define BR_MCG_C4_SCFTRIM(v)   (BME_UBFX8(HW_MCG_C4_ADDR, BP_MCG_C4_SCFTRIM, 1))
#endif

//! @brief Format value for bitfield MCG_C4_SCFTRIM.
#define BF_MCG_C4_SCFTRIM(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C4_SCFTRIM), uint8_t) & BM_MCG_C4_SCFTRIM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SCFTRIM field to a new value.
#define BW_MCG_C4_SCFTRIM(v)   (BME_BFI8(HW_MCG_C4_ADDR, ((uint8_t)(v) << BP_MCG_C4_SCFTRIM), BP_MCG_C4_SCFTRIM, 1))
#endif
//@}

/*! @name Register MCG_C4, field FCTRIM[4:1] (RW)
 *
 * FCTRIM A value for FCTRIM is loaded during reset from a factory programmed location. controls the
 * fast internal reference clock frequency by controlling the fast internal reference clock period.
 * The FCTRIM bits are binary weighted, that is, bit 1 adjusts twice as much as bit 0. Increasing
 * the binary value increases the period, and decreasing the value decreases the period. If an
 * FCTRIM[3:0] value stored in nonvolatile memory is to be used, it is your responsibility to copy
 * that value from the nonvolatile memory location to this register.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_MCG_C4_FCTRIM      (1U)      //!< Bit position for MCG_C4_FCTRIM.
#define BM_MCG_C4_FCTRIM      (0x1eU)  //!< Bit mask for MCG_C4_FCTRIM.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C4_FCTRIM field.
#define BR_MCG_C4_FCTRIM(v)   (BME_UBFX8(HW_MCG_C4_ADDR, BP_MCG_C4_FCTRIM, 4))
#endif

//! @brief Format value for bitfield MCG_C4_FCTRIM.
#define BF_MCG_C4_FCTRIM(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C4_FCTRIM), uint8_t) & BM_MCG_C4_FCTRIM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the FCTRIM field to a new value.
#define BW_MCG_C4_FCTRIM(v)   (BME_BFI8(HW_MCG_C4_ADDR, ((uint8_t)(v) << BP_MCG_C4_FCTRIM), BP_MCG_C4_FCTRIM, 4))
#endif
//@}

/*! @name Register MCG_C4, field DRST_DRS[6:5] (RW)
 *
 * The DRS bits select the frequency range for the FLL output, DCOOUT. When the LP bit is set,
 * writes to the DRS bits are ignored. The DRST read field indicates the current frequency range for
 * DCOOUT. The DRST field does not update immediately after a write to the DRS field due to internal
 * synchronization between clock domains. See the DCO Frequency Range table for more details.
 *
 * Values:
 * - 00 - Encoding 0 — Low range (reset default).
 * - 01 - Encoding 1 — Mid range.
 * - 10 - Encoding 2 — Mid-high range.
 * - 11 - Encoding 3 — High range.
 */
//@{
#define BP_MCG_C4_DRST_DRS      (5U)      //!< Bit position for MCG_C4_DRST_DRS.
#define BM_MCG_C4_DRST_DRS      (0x60U)  //!< Bit mask for MCG_C4_DRST_DRS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C4_DRST_DRS field.
#define BR_MCG_C4_DRST_DRS(v)   (BME_UBFX8(HW_MCG_C4_ADDR, BP_MCG_C4_DRST_DRS, 2))
#endif

//! @brief Format value for bitfield MCG_C4_DRST_DRS.
#define BF_MCG_C4_DRST_DRS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C4_DRST_DRS), uint8_t) & BM_MCG_C4_DRST_DRS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DRST_DRS field to a new value.
#define BW_MCG_C4_DRST_DRS(v)   (BME_BFI8(HW_MCG_C4_ADDR, ((uint8_t)(v) << BP_MCG_C4_DRST_DRS), BP_MCG_C4_DRST_DRS, 2))
#endif
//@}

/*! @name Register MCG_C4, field DMX32[7] (RW)
 *
 * The DMX32 bit controls whether the DCO frequency range is narrowed to its maximum frequency with
 * a 32.768 kHz reference. The following table identifies settings for the DCO frequency range. The
 * system clocks derived from this source should not exceed their specified maximums. DRST_DRS DMX32
 * Reference Range FLL Factor DCO Range 00 0 31.25–39.0625 kHz 640 20–25 MHz 1 32.768 kHz 732 24 MHz
 * 01 0 31.25–39.0625 kHz 1280 40–50 MHz 1 32.768 kHz 1464 48 MHz 10 0 31.25–39.0625 kHz 1920 60–75
 * MHz 1 32.768 kHz 2197 72 MHz 11 0 31.25–39.0625 kHz 2560 80–100 MHz 1 32.768 kHz 2929 96 MHz
 *
 * Values:
 * - 0 - DCO has a default range of 25%.
 * - 1 - DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
 */
//@{
#define BP_MCG_C4_DMX32      (7U)      //!< Bit position for MCG_C4_DMX32.
#define BM_MCG_C4_DMX32      (0x80U)  //!< Bit mask for MCG_C4_DMX32.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C4_DMX32 field.
#define BR_MCG_C4_DMX32(v)   (BME_UBFX8(HW_MCG_C4_ADDR, BP_MCG_C4_DMX32, 1))
#endif

//! @brief Format value for bitfield MCG_C4_DMX32.
#define BF_MCG_C4_DMX32(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C4_DMX32), uint8_t) & BM_MCG_C4_DMX32)

#ifndef __LANGUAGE_ASM__
//! @brief Set the DMX32 field to a new value.
#define BW_MCG_C4_DMX32(v)   (BME_BFI8(HW_MCG_C4_ADDR, ((uint8_t)(v) << BP_MCG_C4_DMX32), BP_MCG_C4_DMX32, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_C5 - MCG Control 5 Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_C5 - MCG Control 5 Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_c5
{
    uint8_t U;
    struct _hw_mcg_c5_bitfields
    {
        uint8_t PRDIV : 5; //!< [4:0] PLL External Reference Divider
        uint8_t PLLSTEN : 1; //!< [5] PLL Stop Enable
        uint8_t PLLCLKEN : 1; //!< [6] PLL Clock Enable
        uint8_t RESERVED0 : 1; //!< [7] 
    } B;
} hw_mcg_c5_t;
#endif

/*!
 * @name Constants and macros for entire MCG_C5 register
 */
//@{
#define HW_MCG_C5_ADDR      (REGS_MCG_BASE + 0x4U)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_C5           (*(__IO hw_mcg_c5_t *) HW_MCG_C5_ADDR)
#define HW_MCG_C5_RD()      (HW_MCG_C5.U)
#define HW_MCG_C5_WR(v)     (HW_MCG_C5.U = (v))
#define HW_MCG_C5_SET(v)    (BME_OR8(HW_MCG_C5_ADDR, (uint8_t)(v)))
#define HW_MCG_C5_CLR(v)    (BME_AND8(HW_MCG_C5_ADDR, (uint8_t)(~(v))))
#define HW_MCG_C5_TOG(v)    (BME_XOR8(HW_MCG_C5_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_C5 bitfields
 */

/*! @name Register MCG_C5, field PRDIV[4:0] (RW)
 *
 * Selects the amount to divide down the external reference clock for the PLL. The resulting
 * frequency must be in the range of 2 MHz to 4 MHz. After the PLL is enabled (by setting either
 * PLLCLKEN or PLLS), the PRDIV value must not be changed when LOCK is zero. PLL External Reference
 * Divide Factor PRDIV Divide Factor PRDIV Divide Factor PRDIV Divide Factor PRDIV Divide Factor
 * 00000 1 01000 9 10000 17 11000 25 00001 2 01001 10 10001 18 11001 Reserved 00010 3 01010 11 10010
 * 19 11010 Reserved 00011 4 01011 12 10011 20 11011 Reserved 00100 5 01100 13 10100 21 11100
 * Reserved 00101 6 01101 14 10101 22 11101 Reserved 00110 7 01110 15 10110 23 11110 Reserved 00111
 * 8 01111 16 10111 24 11111 Reserved
 */
//@{
#define BP_MCG_C5_PRDIV      (0U)      //!< Bit position for MCG_C5_PRDIV.
#define BM_MCG_C5_PRDIV      (0x1fU)  //!< Bit mask for MCG_C5_PRDIV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C5_PRDIV field.
#define BR_MCG_C5_PRDIV(v)   (BME_UBFX8(HW_MCG_C5_ADDR, BP_MCG_C5_PRDIV, 5))
#endif

//! @brief Format value for bitfield MCG_C5_PRDIV.
#define BF_MCG_C5_PRDIV(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C5_PRDIV), uint8_t) & BM_MCG_C5_PRDIV)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PRDIV field to a new value.
#define BW_MCG_C5_PRDIV(v)   (BME_BFI8(HW_MCG_C5_ADDR, ((uint8_t)(v) << BP_MCG_C5_PRDIV), BP_MCG_C5_PRDIV, 5))
#endif
//@}

/*! @name Register MCG_C5, field PLLSTEN[5] (RW)
 *
 * Enables the PLL Clock during Normal Stop. In Low Power Stop mode, the PLL clock gets disabled
 * even if PLLSTEN =1. All other power modes, PLLSTEN bit has no affect and does not enable the PLL
 * Clock to run if it is written to 1.
 *
 * Values:
 * - 0 - MCGPLLCLK is disabled in any of the Stop modes.
 * - 1 - MCGPLLCLK is enabled if system is in Normal Stop mode.
 */
//@{
#define BP_MCG_C5_PLLSTEN      (5U)      //!< Bit position for MCG_C5_PLLSTEN.
#define BM_MCG_C5_PLLSTEN      (0x20U)  //!< Bit mask for MCG_C5_PLLSTEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C5_PLLSTEN field.
#define BR_MCG_C5_PLLSTEN(v)   (BME_UBFX8(HW_MCG_C5_ADDR, BP_MCG_C5_PLLSTEN, 1))
#endif

//! @brief Format value for bitfield MCG_C5_PLLSTEN.
#define BF_MCG_C5_PLLSTEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C5_PLLSTEN), uint8_t) & BM_MCG_C5_PLLSTEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PLLSTEN field to a new value.
#define BW_MCG_C5_PLLSTEN(v)   (BME_BFI8(HW_MCG_C5_ADDR, ((uint8_t)(v) << BP_MCG_C5_PLLSTEN), BP_MCG_C5_PLLSTEN, 1))
#endif
//@}

/*! @name Register MCG_C5, field PLLCLKEN[6] (RW)
 *
 * Enables the PLL independent of PLLS and enables the PLL clock for use as MCGPLLCLK. (PRDIV needs
 * to be programmed to the correct divider to generate a PLL reference clock in the range of 2 - 4
 * MHz range prior to setting the PLLCLKEN bit). Setting PLLCLKEN will enable the external
 * oscillator if not already enabled. Whenever the PLL is being enabled by means of the PLLCLKEN
 * bit, and the external oscillator is being used as the reference clock, the OSCINIT bit should be
 * checked to make sure it is set.
 *
 * Values:
 * - 0 - MCGPLLCLK is inactive.
 * - 1 - MCGPLLCLK is active.
 */
//@{
#define BP_MCG_C5_PLLCLKEN      (6U)      //!< Bit position for MCG_C5_PLLCLKEN.
#define BM_MCG_C5_PLLCLKEN      (0x40U)  //!< Bit mask for MCG_C5_PLLCLKEN.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C5_PLLCLKEN field.
#define BR_MCG_C5_PLLCLKEN(v)   (BME_UBFX8(HW_MCG_C5_ADDR, BP_MCG_C5_PLLCLKEN, 1))
#endif

//! @brief Format value for bitfield MCG_C5_PLLCLKEN.
#define BF_MCG_C5_PLLCLKEN(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C5_PLLCLKEN), uint8_t) & BM_MCG_C5_PLLCLKEN)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PLLCLKEN field to a new value.
#define BW_MCG_C5_PLLCLKEN(v)   (BME_BFI8(HW_MCG_C5_ADDR, ((uint8_t)(v) << BP_MCG_C5_PLLCLKEN), BP_MCG_C5_PLLCLKEN, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_C6 - MCG Control 6 Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_C6 - MCG Control 6 Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_c6
{
    uint8_t U;
    struct _hw_mcg_c6_bitfields
    {
        uint8_t VDIV : 5; //!< [4:0] VCO Divider
        uint8_t CME : 1; //!< [5] Clock Monitor Enable
        uint8_t PLLS : 1; //!< [6] PLL Select
        uint8_t LOLIE : 1; //!< [7] Loss of Lock Interrrupt Enable
    } B;
} hw_mcg_c6_t;
#endif

/*!
 * @name Constants and macros for entire MCG_C6 register
 */
//@{
#define HW_MCG_C6_ADDR      (REGS_MCG_BASE + 0x5U)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_C6           (*(__IO hw_mcg_c6_t *) HW_MCG_C6_ADDR)
#define HW_MCG_C6_RD()      (HW_MCG_C6.U)
#define HW_MCG_C6_WR(v)     (HW_MCG_C6.U = (v))
#define HW_MCG_C6_SET(v)    (BME_OR8(HW_MCG_C6_ADDR, (uint8_t)(v)))
#define HW_MCG_C6_CLR(v)    (BME_AND8(HW_MCG_C6_ADDR, (uint8_t)(~(v))))
#define HW_MCG_C6_TOG(v)    (BME_XOR8(HW_MCG_C6_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_C6 bitfields
 */

/*! @name Register MCG_C6, field VDIV[4:0] (RW)
 *
 * Selects the amount to divide the VCO output of the PLL. The VDIV bits establish the
 * multiplication factor (M) applied to the reference clock frequency. After the PLL is enabled (by
 * setting either PLLCLKEN or PLLS), the VDIV value must not be changed when LOCK is zero. PLL VCO
 * Divide Factor VDIV Multiply Factor VDIV Multiply Factor VDIV Multiply Factor VDIV Multiply Factor
 * 00000 24 01000 32 10000 40 11000 48 00001 25 01001 33 10001 41 11001 49 00010 26 01010 34 10010
 * 42 11010 50 00011 27 01011 35 10011 43 11011 51 00100 28 01100 36 10100 44 11100 52 00101 29
 * 01101 37 10101 45 11101 53 00110 30 01110 38 10110 46 11110 54 00111 31 01111 39 10111 47 11111
 * 55
 *
 * Values:
 * -  - 
 */
//@{
#define BP_MCG_C6_VDIV      (0U)      //!< Bit position for MCG_C6_VDIV.
#define BM_MCG_C6_VDIV      (0x1fU)  //!< Bit mask for MCG_C6_VDIV.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C6_VDIV field.
#define BR_MCG_C6_VDIV(v)   (BME_UBFX8(HW_MCG_C6_ADDR, BP_MCG_C6_VDIV, 5))
#endif

//! @brief Format value for bitfield MCG_C6_VDIV.
#define BF_MCG_C6_VDIV(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C6_VDIV), uint8_t) & BM_MCG_C6_VDIV)

#ifndef __LANGUAGE_ASM__
//! @brief Set the VDIV field to a new value.
#define BW_MCG_C6_VDIV(v)   (BME_BFI8(HW_MCG_C6_ADDR, ((uint8_t)(v) << BP_MCG_C6_VDIV), BP_MCG_C6_VDIV, 5))
#endif
//@}

/*! @name Register MCG_C6, field CME[5] (RW)
 *
 * Determines if a reset request is made following a loss of external clock indication. The CME bit
 * should only be set to a logic 1 when the MCG is in an operational mode that uses the external
 * clock (FEE, FBE, PEE, PBE, or BLPE). Whenever the CME bit is set to a logic 1, the value of the
 * RANGE bits in the C2 register should not be changed. CME bit should be set to a logic 0 before
 * the MCG enters any Stop mode. Otherwise, a reset request may occur when in Stop mode. CME should
 * also be set to a logic 0 before entering VLPR or VLPW power modes if the MCG is in BLPE mode.
 *
 * Values:
 * - 0 - External clock monitor is disabled.
 * - 1 - Generate a reset request on loss of external clock.
 */
//@{
#define BP_MCG_C6_CME      (5U)      //!< Bit position for MCG_C6_CME.
#define BM_MCG_C6_CME      (0x20U)  //!< Bit mask for MCG_C6_CME.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C6_CME field.
#define BR_MCG_C6_CME(v)   (BME_UBFX8(HW_MCG_C6_ADDR, BP_MCG_C6_CME, 1))
#endif

//! @brief Format value for bitfield MCG_C6_CME.
#define BF_MCG_C6_CME(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C6_CME), uint8_t) & BM_MCG_C6_CME)

#ifndef __LANGUAGE_ASM__
//! @brief Set the CME field to a new value.
#define BW_MCG_C6_CME(v)   (BME_BFI8(HW_MCG_C6_ADDR, ((uint8_t)(v) << BP_MCG_C6_CME), BP_MCG_C6_CME, 1))
#endif
//@}

/*! @name Register MCG_C6, field PLLS[6] (RW)
 *
 * Controls whether the PLL or FLL output is selected as the MCG source when CLKS[1:0]=00. If the
 * PLLS bit is cleared and PLLCLKEN is not set, the PLL is disabled in all modes. If the PLLS is
 * set, the FLL is disabled in all modes.
 *
 * Values:
 * - 0 - FLL is selected.
 * - 1 - PLL is selected (PRDIV need to be programmed to the correct divider to generate a PLL reference
 *     clock in the range of 2–4 MHz prior to setting the PLLS bit).
 */
//@{
#define BP_MCG_C6_PLLS      (6U)      //!< Bit position for MCG_C6_PLLS.
#define BM_MCG_C6_PLLS      (0x40U)  //!< Bit mask for MCG_C6_PLLS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C6_PLLS field.
#define BR_MCG_C6_PLLS(v)   (BME_UBFX8(HW_MCG_C6_ADDR, BP_MCG_C6_PLLS, 1))
#endif

//! @brief Format value for bitfield MCG_C6_PLLS.
#define BF_MCG_C6_PLLS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C6_PLLS), uint8_t) & BM_MCG_C6_PLLS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the PLLS field to a new value.
#define BW_MCG_C6_PLLS(v)   (BME_BFI8(HW_MCG_C6_ADDR, ((uint8_t)(v) << BP_MCG_C6_PLLS), BP_MCG_C6_PLLS, 1))
#endif
//@}

/*! @name Register MCG_C6, field LOLIE[7] (RW)
 *
 * Determines if an interrupt request is made following a loss of lock indication. This bit only has
 * an effect when LOLS is set.
 *
 * Values:
 * - 0 - No interrupt request is generated on loss of lock.
 * - 1 - Generate an interrupt request on loss of lock.
 */
//@{
#define BP_MCG_C6_LOLIE      (7U)      //!< Bit position for MCG_C6_LOLIE.
#define BM_MCG_C6_LOLIE      (0x80U)  //!< Bit mask for MCG_C6_LOLIE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C6_LOLIE field.
#define BR_MCG_C6_LOLIE(v)   (BME_UBFX8(HW_MCG_C6_ADDR, BP_MCG_C6_LOLIE, 1))
#endif

//! @brief Format value for bitfield MCG_C6_LOLIE.
#define BF_MCG_C6_LOLIE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C6_LOLIE), uint8_t) & BM_MCG_C6_LOLIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOLIE field to a new value.
#define BW_MCG_C6_LOLIE(v)   (BME_BFI8(HW_MCG_C6_ADDR, ((uint8_t)(v) << BP_MCG_C6_LOLIE), BP_MCG_C6_LOLIE, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_S - MCG Status Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_S - MCG Status Register (RO)
 *
 * Reset value: 0x10U
 */
typedef union _hw_mcg_s
{
    uint8_t U;
    struct _hw_mcg_s_bitfields
    {
        uint8_t IRCST : 1; //!< [0] Internal Reference Clock Status
        uint8_t OSCINIT0 : 1; //!< [1] OSC Initialization
        uint8_t CLKST : 2; //!< [3:2] Clock Mode Status
        uint8_t IREFST : 1; //!< [4] Internal Reference Status
        uint8_t PLLST : 1; //!< [5] PLL Select Status
        uint8_t LOCK0 : 1; //!< [6] Lock Status
        uint8_t LOLS : 1; //!< [7] Loss of Lock Status
    } B;
} hw_mcg_s_t;
#endif

/*!
 * @name Constants and macros for entire MCG_S register
 */
//@{
#define HW_MCG_S_ADDR      (REGS_MCG_BASE + 0x6U)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_S           (*(__I hw_mcg_s_t *) HW_MCG_S_ADDR)
#define HW_MCG_S_RD()      (HW_MCG_S.U)
#endif
//@}

/*
 * constants & macros for individual MCG_S bitfields
 */

/*! @name Register MCG_S, field IRCST[0] (RO)
 *
 * The IRCST bit indicates the current source for the internal reference clock select clock
 * (IRCSCLK). The IRCST bit does not update immediately after a write to the IRCS bit due to
 * internal synchronization between clock domains. The IRCST bit will only be updated if the
 * internal reference clock is enabled, either by the MCG being in a mode that uses the IRC or by
 * setting the C1[IRCLKEN] bit .
 *
 * Values:
 * - 0 - Source of internal reference clock is the slow clock (32 kHz IRC).
 * - 1 - Source of internal reference clock is the fast clock (4 MHz IRC).
 */
//@{
#define BP_MCG_S_IRCST      (0U)      //!< Bit position for MCG_S_IRCST.
#define BM_MCG_S_IRCST      (0x01U)  //!< Bit mask for MCG_S_IRCST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_S_IRCST field.
#define BR_MCG_S_IRCST(v)   (BME_UBFX8(HW_MCG_S_ADDR, BP_MCG_S_IRCST, 1))
#endif
//@}

/*! @name Register MCG_S, field OSCINIT[1] (RO)
 *
 * This bit, which resets to 0, is set to 1 after the initialization cycles of the crystal
 * oscillator clock have completed. After being set, the bit is cleared to 0 if the OSC is
 * subsequently disabled. See the OSC module's detailed description for more information.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_MCG_S_OSCINIT      (1U)      //!< Bit position for MCG_S_OSCINIT.
#define BM_MCG_S_OSCINIT      (0x02U)  //!< Bit mask for MCG_S_OSCINIT.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_S_OSCINIT field.
#define BR_MCG_S_OSCINIT(v)   (BME_UBFX8(HW_MCG_S_ADDR, BP_MCG_S_OSCINIT, 1))
#endif
//@}

/*! @name Register MCG_S, field CLKST[3:2] (RO)
 *
 * These bits indicate the current clock mode. The CLKST bits do not update immediately after a
 * write to the CLKS bits due to internal synchronization between clock domains.
 *
 * Values:
 * - 00 - Encoding 0 — Output of the FLL is selected (reset default).
 * - 01 - Encoding 1 — Internal reference clock is selected.
 * - 10 - Encoding 2 — External reference clock is selected.
 * - 11 - Encoding 3 — Output of the PLL is selected .
 */
//@{
#define BP_MCG_S_CLKST      (2U)      //!< Bit position for MCG_S_CLKST.
#define BM_MCG_S_CLKST      (0x0cU)  //!< Bit mask for MCG_S_CLKST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_S_CLKST field.
#define BR_MCG_S_CLKST(v)   (BME_UBFX8(HW_MCG_S_ADDR, BP_MCG_S_CLKST, 2))
#endif
//@}

/*! @name Register MCG_S, field IREFST[4] (RO)
 *
 * This bit indicates the current source for the FLL reference clock. The IREFST bit does not update
 * immediately after a write to the IREFS bit due to internal synchronization between clock domains.
 *
 * Values:
 * - 0 - Source of FLL reference clock is the external reference clock.
 * - 1 - Source of FLL reference clock is the internal reference clock.
 */
//@{
#define BP_MCG_S_IREFST      (4U)      //!< Bit position for MCG_S_IREFST.
#define BM_MCG_S_IREFST      (0x10U)  //!< Bit mask for MCG_S_IREFST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_S_IREFST field.
#define BR_MCG_S_IREFST(v)   (BME_UBFX8(HW_MCG_S_ADDR, BP_MCG_S_IREFST, 1))
#endif
//@}

/*! @name Register MCG_S, field PLLST[5] (RO)
 *
 * This bit indicates the clock source selected by PLLS . The PLLST bit does not update immediately
 * after a write to the PLLS bit due to internal synchronization between clock domains.
 *
 * Values:
 * - 0 - Source of PLLS clock is FLL clock.
 * - 1 - Source of PLLS clock is PLL output clock.
 */
//@{
#define BP_MCG_S_PLLST      (5U)      //!< Bit position for MCG_S_PLLST.
#define BM_MCG_S_PLLST      (0x20U)  //!< Bit mask for MCG_S_PLLST.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_S_PLLST field.
#define BR_MCG_S_PLLST(v)   (BME_UBFX8(HW_MCG_S_ADDR, BP_MCG_S_PLLST, 1))
#endif
//@}

/*! @name Register MCG_S, field LOCK0[6] (RO)
 *
 * This bit indicates whether the PLL has acquired lock. Lock detection is only enabled when the PLL
 * is enabled (either through clock mode selection or PLLCLKEN0=1 setting). While the PLL clock is
 * locking to the desired frequency, the MCG PLL clock (MCGPLLCLK) will be gated off until the LOCK
 * bit gets asserted. If the lock status bit is set, changing the value of the PRDIV [4:0] bits in
 * the C5 register or the VDIV0[4:0] bits in the C6 register causes the lock status bit to clear and
 * stay cleared until the PLL has reacquired lock. Entry into LLS, VLPS, or regular Stop with
 * PLLSTEN=0 also causes the lock status bit to clear and stay cleared until the Stop mode is exited
 * and the PLL has reacquired lock. Any time the PLL is enabled and the LOCK0 bit is cleared, the
 * MCGPLLCLK will be gated off until the LOCK0 bit is asserted again.
 *
 * Values:
 * - 0 - PLL is currently unlocked.
 * - 1 - PLL is currently locked.
 */
//@{
#define BP_MCG_S_LOCK0      (6U)      //!< Bit position for MCG_S_LOCK0.
#define BM_MCG_S_LOCK0      (0x40U)  //!< Bit mask for MCG_S_LOCK0.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_S_LOCK0 field.
#define BR_MCG_S_LOCK0(v)   (BME_UBFX8(HW_MCG_S_ADDR, BP_MCG_S_LOCK0, 1))
#endif
//@}

/*! @name Register MCG_S, field LOLS[7] (RO)
 *
 * This bit is a sticky bit indicating the lock status for the PLL. LOLS is set if after acquiring
 * lock, the PLL output frequency has fallen outside the lock exit frequency tolerance, D unl .
 * LOLIE determines whether an interrupt request is made when LOLS is set. LOLRE determines whether
 * a reset request is made when LOLS is set. This bit is cleared by reset or by writing a logic 1 to
 * it when set. Writing a logic 0 to this bit has no effect.
 *
 * Values:
 * - 0 - PLL has not lost lock since LOLS was last cleared.
 * - 1 - PLL has lost lock since LOLS was last cleared.
 */
//@{
#define BP_MCG_S_LOLS      (7U)      //!< Bit position for MCG_S_LOLS.
#define BM_MCG_S_LOLS      (0x80U)  //!< Bit mask for MCG_S_LOLS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_S_LOLS field.
#define BR_MCG_S_LOLS(v)   (BME_UBFX8(HW_MCG_S_ADDR, BP_MCG_S_LOLS, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_ATC - MCG Auto Trim Control Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_ATC - MCG Auto Trim Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_atc
{
    uint8_t U;
    struct _hw_mcg_atc_bitfields
    {
        uint8_t RESERVED0 : 5; //!< [4:0] 
        uint8_t ATMF : 1; //!< [5] Automatic Trim machine Fail Flag
        uint8_t ATMS : 1; //!< [6] Automatic Trim Machine Select
        uint8_t ATME : 1; //!< [7] Automatic Trim Machine Enable
    } B;
} hw_mcg_atc_t;
#endif

/*!
 * @name Constants and macros for entire MCG_ATC register
 */
//@{
#define HW_MCG_ATC_ADDR      (REGS_MCG_BASE + 0x8U)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_ATC           (*(__IO hw_mcg_atc_t *) HW_MCG_ATC_ADDR)
#define HW_MCG_ATC_RD()      (HW_MCG_ATC.U)
#define HW_MCG_ATC_WR(v)     (HW_MCG_ATC.U = (v))
#define HW_MCG_ATC_SET(v)    (BME_OR8(HW_MCG_ATC_ADDR, (uint8_t)(v)))
#define HW_MCG_ATC_CLR(v)    (BME_AND8(HW_MCG_ATC_ADDR, (uint8_t)(~(v))))
#define HW_MCG_ATC_TOG(v)    (BME_XOR8(HW_MCG_ATC_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_ATC bitfields
 */

/*! @name Register MCG_ATC, field ATMF[5] (RO)
 *
 * Fail flag for the Automatic Trim Machine (ATM). This bit asserts when the Automatic Trim Machine
 * is enabled (ATME=1) and a write to the C1, C3, C4, and ATC registers is detected or the MCG
 * enters into any Stop mode. A write to ATMF clears the flag.
 *
 * Values:
 * - 0 - Automatic Trim Machine completed normally.
 * - 1 - Automatic Trim Machine failed.
 */
//@{
#define BP_MCG_ATC_ATMF      (5U)      //!< Bit position for MCG_ATC_ATMF.
#define BM_MCG_ATC_ATMF      (0x20U)  //!< Bit mask for MCG_ATC_ATMF.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_ATC_ATMF field.
#define BR_MCG_ATC_ATMF(v)   (BME_UBFX8(HW_MCG_ATC_ADDR, BP_MCG_ATC_ATMF, 1))
#endif
//@}

/*! @name Register MCG_ATC, field ATMS[6] (RW)
 *
 * Selects the IRCS clock for Auto Trim Test.
 *
 * Values:
 * - 0 - 32 kHz Internal Reference Clock selected.
 * - 1 - 4 MHz Internal Reference Clock selected.
 */
//@{
#define BP_MCG_ATC_ATMS      (6U)      //!< Bit position for MCG_ATC_ATMS.
#define BM_MCG_ATC_ATMS      (0x40U)  //!< Bit mask for MCG_ATC_ATMS.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_ATC_ATMS field.
#define BR_MCG_ATC_ATMS(v)   (BME_UBFX8(HW_MCG_ATC_ADDR, BP_MCG_ATC_ATMS, 1))
#endif

//! @brief Format value for bitfield MCG_ATC_ATMS.
#define BF_MCG_ATC_ATMS(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_ATC_ATMS), uint8_t) & BM_MCG_ATC_ATMS)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ATMS field to a new value.
#define BW_MCG_ATC_ATMS(v)   (BME_BFI8(HW_MCG_ATC_ADDR, ((uint8_t)(v) << BP_MCG_ATC_ATMS), BP_MCG_ATC_ATMS, 1))
#endif
//@}

/*! @name Register MCG_ATC, field ATME[7] (RW)
 *
 * Enables the Auto Trim Machine to start automatically trimming the selected Internal Reference
 * Clock. ATME deasserts after the Auto Trim Machine has completed trimming all trim bits of the
 * IRCS clock selected by the ATMS bit. Writing to C1, C3, C4, and ATC registers or entering Stop
 * mode aborts the auto trim operation and clears this bit.
 *
 * Values:
 * - 0 - Auto Trim Machine disabled.
 * - 1 - Auto Trim Machine enabled.
 */
//@{
#define BP_MCG_ATC_ATME      (7U)      //!< Bit position for MCG_ATC_ATME.
#define BM_MCG_ATC_ATME      (0x80U)  //!< Bit mask for MCG_ATC_ATME.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_ATC_ATME field.
#define BR_MCG_ATC_ATME(v)   (BME_UBFX8(HW_MCG_ATC_ADDR, BP_MCG_ATC_ATME, 1))
#endif

//! @brief Format value for bitfield MCG_ATC_ATME.
#define BF_MCG_ATC_ATME(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_ATC_ATME), uint8_t) & BM_MCG_ATC_ATME)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ATME field to a new value.
#define BW_MCG_ATC_ATME(v)   (BME_BFI8(HW_MCG_ATC_ADDR, ((uint8_t)(v) << BP_MCG_ATC_ATME), BP_MCG_ATC_ATME, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_ATCVH - MCG Auto Trim Compare Value High Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_ATCVH - MCG Auto Trim Compare Value High Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_atcvh
{
    uint8_t U;
    struct _hw_mcg_atcvh_bitfields
    {
        uint8_t ATCVH : 8; //!< [7:0] ATM Compare Value High
    } B;
} hw_mcg_atcvh_t;
#endif

/*!
 * @name Constants and macros for entire MCG_ATCVH register
 */
//@{
#define HW_MCG_ATCVH_ADDR      (REGS_MCG_BASE + 0xaU)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_ATCVH           (*(__IO hw_mcg_atcvh_t *) HW_MCG_ATCVH_ADDR)
#define HW_MCG_ATCVH_RD()      (HW_MCG_ATCVH.U)
#define HW_MCG_ATCVH_WR(v)     (HW_MCG_ATCVH.U = (v))
#define HW_MCG_ATCVH_SET(v)    (BME_OR8(HW_MCG_ATCVH_ADDR, (uint8_t)(v)))
#define HW_MCG_ATCVH_CLR(v)    (BME_AND8(HW_MCG_ATCVH_ADDR, (uint8_t)(~(v))))
#define HW_MCG_ATCVH_TOG(v)    (BME_XOR8(HW_MCG_ATCVH_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_ATCVH bitfields
 */

/*! @name Register MCG_ATCVH, field ATCVH[7:0] (RW)
 *
 * Values are used by Auto Trim Machine to compare and adjust Internal Reference trim values during
 * ATM SAR conversion.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_MCG_ATCVH_ATCVH      (0U)      //!< Bit position for MCG_ATCVH_ATCVH.
#define BM_MCG_ATCVH_ATCVH      (0xffU)  //!< Bit mask for MCG_ATCVH_ATCVH.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_ATCVH_ATCVH field.
#define BR_MCG_ATCVH_ATCVH(v)   (BME_UBFX8(HW_MCG_ATCVH_ADDR, BP_MCG_ATCVH_ATCVH, 8))
#endif

//! @brief Format value for bitfield MCG_ATCVH_ATCVH.
#define BF_MCG_ATCVH_ATCVH(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_ATCVH_ATCVH), uint8_t) & BM_MCG_ATCVH_ATCVH)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ATCVH field to a new value.
#define BW_MCG_ATCVH_ATCVH(v)   (BME_BFI8(HW_MCG_ATCVH_ADDR, ((uint8_t)(v) << BP_MCG_ATCVH_ATCVH), BP_MCG_ATCVH_ATCVH, 8))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_ATCVL - MCG Auto Trim Compare Value Low Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_ATCVL - MCG Auto Trim Compare Value Low Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_atcvl
{
    uint8_t U;
    struct _hw_mcg_atcvl_bitfields
    {
        uint8_t ATCVL : 8; //!< [7:0] ATM Compare Value Low
    } B;
} hw_mcg_atcvl_t;
#endif

/*!
 * @name Constants and macros for entire MCG_ATCVL register
 */
//@{
#define HW_MCG_ATCVL_ADDR      (REGS_MCG_BASE + 0xbU)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_ATCVL           (*(__IO hw_mcg_atcvl_t *) HW_MCG_ATCVL_ADDR)
#define HW_MCG_ATCVL_RD()      (HW_MCG_ATCVL.U)
#define HW_MCG_ATCVL_WR(v)     (HW_MCG_ATCVL.U = (v))
#define HW_MCG_ATCVL_SET(v)    (BME_OR8(HW_MCG_ATCVL_ADDR, (uint8_t)(v)))
#define HW_MCG_ATCVL_CLR(v)    (BME_AND8(HW_MCG_ATCVL_ADDR, (uint8_t)(~(v))))
#define HW_MCG_ATCVL_TOG(v)    (BME_XOR8(HW_MCG_ATCVL_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_ATCVL bitfields
 */

/*! @name Register MCG_ATCVL, field ATCVL[7:0] (RW)
 *
 * Values are used by Auto Trim Machine to compare and adjust Internal Reference trim values during
 * ATM SAR conversion.
 *
 * Values:
 * -  - 
 */
//@{
#define BP_MCG_ATCVL_ATCVL      (0U)      //!< Bit position for MCG_ATCVL_ATCVL.
#define BM_MCG_ATCVL_ATCVL      (0xffU)  //!< Bit mask for MCG_ATCVL_ATCVL.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_ATCVL_ATCVL field.
#define BR_MCG_ATCVL_ATCVL(v)   (BME_UBFX8(HW_MCG_ATCVL_ADDR, BP_MCG_ATCVL_ATCVL, 8))
#endif

//! @brief Format value for bitfield MCG_ATCVL_ATCVL.
#define BF_MCG_ATCVL_ATCVL(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_ATCVL_ATCVL), uint8_t) & BM_MCG_ATCVL_ATCVL)

#ifndef __LANGUAGE_ASM__
//! @brief Set the ATCVL field to a new value.
#define BW_MCG_ATCVL_ATCVL(v)   (BME_BFI8(HW_MCG_ATCVL_ADDR, ((uint8_t)(v) << BP_MCG_ATCVL_ATCVL), BP_MCG_ATCVL_ATCVL, 8))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_C7 - MCG Control 7 Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_C7 - MCG Control 7 Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_c7
{
    uint8_t U;
    struct _hw_mcg_c7_bitfields
    {
        uint8_t RESERVED1 : 8; //!< [7:0] Reserved.
    } B;
} hw_mcg_c7_t;
#endif

/*!
 * @name Constants and macros for entire MCG_C7 register
 */
//@{
#define HW_MCG_C7_ADDR      (REGS_MCG_BASE + 0xcU)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_C7           (*(__IO hw_mcg_c7_t *) HW_MCG_C7_ADDR)
#define HW_MCG_C7_RD()      (HW_MCG_C7.U)
#define HW_MCG_C7_WR(v)     (HW_MCG_C7.U = (v))
#define HW_MCG_C7_SET(v)    (BME_OR8(HW_MCG_C7_ADDR, (uint8_t)(v)))
#define HW_MCG_C7_CLR(v)    (BME_AND8(HW_MCG_C7_ADDR, (uint8_t)(~(v))))
#define HW_MCG_C7_TOG(v)    (BME_XOR8(HW_MCG_C7_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_C7 bitfields
 */

//-------------------------------------------------------------------------------------------
// HW_MCG_C8 - MCG Control 8 Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_C8 - MCG Control 8 Register (RW)
 *
 * Reset value: 0x80U
 */
typedef union _hw_mcg_c8
{
    uint8_t U;
    struct _hw_mcg_c8_bitfields
    {
        uint8_t RESERVED1 : 6; //!< [5:0] Reserved.
        uint8_t LOLRE : 1; //!< [6] PLL Loss of Lock Reset Enable
        uint8_t RESERVED2 : 1; //!< [7] 
    } B;
} hw_mcg_c8_t;
#endif

/*!
 * @name Constants and macros for entire MCG_C8 register
 */
//@{
#define HW_MCG_C8_ADDR      (REGS_MCG_BASE + 0xdU)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_C8           (*(__IO hw_mcg_c8_t *) HW_MCG_C8_ADDR)
#define HW_MCG_C8_RD()      (HW_MCG_C8.U)
#define HW_MCG_C8_WR(v)     (HW_MCG_C8.U = (v))
#define HW_MCG_C8_SET(v)    (BME_OR8(HW_MCG_C8_ADDR, (uint8_t)(v)))
#define HW_MCG_C8_CLR(v)    (BME_AND8(HW_MCG_C8_ADDR, (uint8_t)(~(v))))
#define HW_MCG_C8_TOG(v)    (BME_XOR8(HW_MCG_C8_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_C8 bitfields
 */

/*! @name Register MCG_C8, field LOLRE[6] (RW)
 *
 * Determines if a interrupt or a reset request is made following a PLL loss of lock.
 *
 * Values:
 * - 0 - Interrupt request is generated on a PLL loss of lock indication. The PLL loss of lock interrupt
 *     enable bit must also be set to generate the interrupt request.
 * - 1 - Generate a reset request on a PLL loss of lock indication.
 */
//@{
#define BP_MCG_C8_LOLRE      (6U)      //!< Bit position for MCG_C8_LOLRE.
#define BM_MCG_C8_LOLRE      (0x40U)  //!< Bit mask for MCG_C8_LOLRE.

#ifndef __LANGUAGE_ASM__
//! @brief Read current value of the MCG_C8_LOLRE field.
#define BR_MCG_C8_LOLRE(v)   (BME_UBFX8(HW_MCG_C8_ADDR, BP_MCG_C8_LOLRE, 1))
#endif

//! @brief Format value for bitfield MCG_C8_LOLRE.
#define BF_MCG_C8_LOLRE(v)   (__REG_VALUE_TYPE((__REG_VALUE_TYPE((v), uint8_t) << BP_MCG_C8_LOLRE), uint8_t) & BM_MCG_C8_LOLRE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOLRE field to a new value.
#define BW_MCG_C8_LOLRE(v)   (BME_BFI8(HW_MCG_C8_ADDR, ((uint8_t)(v) << BP_MCG_C8_LOLRE), BP_MCG_C8_LOLRE, 1))
#endif
//@}

//-------------------------------------------------------------------------------------------
// HW_MCG_C9 - MCG Control 9 Register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_MCG_C9 - MCG Control 9 Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_c9
{
    uint8_t U;
    struct _hw_mcg_c9_bitfields
    {
        uint8_t RESERVED0 : 8; //!< [7:0] Reserved.
    } B;
} hw_mcg_c9_t;
#endif

/*!
 * @name Constants and macros for entire MCG_C9 register
 */
//@{
#define HW_MCG_C9_ADDR      (REGS_MCG_BASE + 0xeU)

#ifndef __LANGUAGE_ASM__
#define HW_MCG_C9           (*(__IO hw_mcg_c9_t *) HW_MCG_C9_ADDR)
#define HW_MCG_C9_RD()      (HW_MCG_C9.U)
#define HW_MCG_C9_WR(v)     (HW_MCG_C9.U = (v))
#define HW_MCG_C9_SET(v)    (BME_OR8(HW_MCG_C9_ADDR, (uint8_t)(v)))
#define HW_MCG_C9_CLR(v)    (BME_AND8(HW_MCG_C9_ADDR, (uint8_t)(~(v))))
#define HW_MCG_C9_TOG(v)    (BME_XOR8(HW_MCG_C9_ADDR, (uint8_t)(v)))
#endif
//@}

/*
 * constants & macros for individual MCG_C9 bitfields
 */

//-------------------------------------------------------------------------------------------
// hw_mcg_t - module struct
//-------------------------------------------------------------------------------------------
/*!
 * @brief All MCG module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_mcg
{
    __IO hw_mcg_c1_t C1; //!< [0x0] MCG Control 1 Register
    __IO hw_mcg_c2_t C2; //!< [0x1] MCG Control 2 Register
    __IO hw_mcg_c3_t C3; //!< [0x2] MCG Control 3 Register
    __IO hw_mcg_c4_t C4; //!< [0x3] MCG Control 4 Register
    __IO hw_mcg_c5_t C5; //!< [0x4] MCG Control 5 Register
    __IO hw_mcg_c6_t C6; //!< [0x5] MCG Control 6 Register
    __I hw_mcg_s_t S; //!< [0x6] MCG Status Register
    uint8_t _reserved0;
    __IO hw_mcg_atc_t ATC; //!< [0x8] MCG Auto Trim Control Register
    uint8_t _reserved1;
    __IO hw_mcg_atcvh_t ATCVH; //!< [0xa] MCG Auto Trim Compare Value High Register
    __IO hw_mcg_atcvl_t ATCVL; //!< [0xb] MCG Auto Trim Compare Value Low Register
    __IO hw_mcg_c7_t C7; //!< [0xc] MCG Control 7 Register
    __IO hw_mcg_c8_t C8; //!< [0xd] MCG Control 8 Register
    __IO hw_mcg_c9_t C9; //!< [0xe] MCG Control 9 Register
} hw_mcg_t;
#pragma pack()

//! @brief Macro to access all MCG registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_MCG</code>.
#define HW_MCG     (*(hw_mcg_t *) REGS_MCG_BASE)
#endif

#endif // __HW_MCG_REGISTERS_H__
// v20/130417/1.2.4
// EOF
