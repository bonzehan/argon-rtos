<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>Argon RTOS: Ar::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Argon RTOS
   &#160;<span id="projectnumber">1.0a2</span>
   </div>
   <div id="projectbrief">Tiny embedded kernel</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Documentation</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ar_1_1_thread.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_ar_1_1_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ar::Thread Class Reference<div class="ingroups"><a class="el" href="group__ar.html">Argon RTOS</a> &raquo; <a class="el" href="group__ar__thread.html">Threads</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ar__classes_8h_source.html">ar_classes.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ar::Thread:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_ar_1_1_thread__inherit__graph.png" border="0" usemap="#_ar_1_1_thread_inherit__map" alt="Inheritance graph"/></div>
<map name="_ar_1_1_thread_inherit__map" id="_ar_1_1_thread_inherit__map">
<area shape="rect" id="node3" href="class_ar_1_1_thread_with_stack.html" title="Template to create a thread and its stack. " alt="" coords="5,152,182,177"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Preemptive thread class. </p>
<p>This thread class implements a preemptive threading system with priorities. The highest priority thread that is ready to run will always get the processor. That means that if there is only one high priority thread, it can starve lower priority threads if it never relinquishes control by sleeping or blocking on a resource. Threads with the same priority will preempt each other in a round robin order every system tick.</p>
<p><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priorities range from 0 to 255. Higher values are higher priorities, with 255 being the highest priority. Priority 0 is reserved for the idle thread.</p>
<p>To create a thread, first allocate it either on the stack or with the new operator. Then call the <a class="el" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23" title="Base initialiser. ">init()</a> method passing in the name, entry point, entry parameter, stack information, and priority. The entry point can be any non-member, i.e static, function that matches the #thread_entry_t prototype. The <a class="el" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23" title="Base initialiser. ">init()</a> method leaves the new thread suspended. To make the new thread eligible to run you must call the <a class="el" href="class_ar_1_1_thread.html#a83520b6fe067f7fa57addca8b6943716" title="Make the thread eligible for execution. ">resume()</a> method on it.</p>
<p>If you want to fully encapsulate a thread you can create a subclass of <a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> that provides its own <a class="el" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23" title="Base initialiser. ">init()</a> method which calls the original <a class="el" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23" title="Base initialiser. ">Thread::init()</a>. You can either pass a pointer to a static function to the base <a class="el" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23" title="Base initialiser. ">init()</a> method, as usual, or you can override the virtual <a class="el" href="class_ar_1_1_thread.html#a99112d3407395ff4bd1384039f6d90c3" title="Virtual thread entry point. ">Thread::threadEntry()</a> method. In the latter case, you can simply pass NULL for the entry point to the base <a class="el" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23" title="Base initialiser. ">init()</a> method. To pass values to the thread function, simply create member variables and set them in your subclass' <a class="el" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23" title="Base initialiser. ">init()</a> method.</p>
<p>Here's an example subclass that uses a member function as the entry point: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MySubclassThread : <span class="keyword">public</span> <a class="code" href="class_ar_1_1_thread.html">Ar::Thread</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> <a class="code" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23">init</a>()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Pass NULL for the entry point. It&#39;s not needed because you are</span></div>
<div class="line">        <span class="comment">// overriding threadEntry() below.</span></div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23">Thread::init</a>(<span class="stringliteral">&quot;my thread&quot;</span>, NULL, <span class="keyword">this</span>, m_stack, <span class="keyword">sizeof</span>(m_stack), 32);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Static memory for the stack.</span></div>
<div class="line">    uint8_t m_stack[4096];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Override the default Thread implementation.</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_ar_1_1_thread.html#a99112d3407395ff4bd1384039f6d90c3">threadEntry</a>()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Implement your thread here.</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">};</div>
</div><!-- fragment --> </div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for Ar::Thread:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_ar_1_1_thread__coll__graph.png" border="0" usemap="#_ar_1_1_thread_coll__map" alt="Collaboration graph"/></div>
<map name="_ar_1_1_thread_coll__map" id="_ar_1_1_thread_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27d5015db1c02a1b1d31f2fe9f78d6dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27d5015db1c02a1b1d31f2fe9f78d6dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a27d5015db1c02a1b1d31f2fe9f78d6dc">Thread</a> ()</td></tr>
<tr class="memdesc:a27d5015db1c02a1b1d31f2fe9f78d6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a27d5015db1c02a1b1d31f2fe9f78d6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8074a9ac574f9b0d517bd4f9837b552"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#ab8074a9ac574f9b0d517bd4f9837b552">Thread</a> (const char *name, <a class="el" href="group__ar__thread.html#gaba7d76c157b709dc09db85462cb75176">ar_thread_entry_t</a> entry, void *param, void *stack, unsigned stackSize, uint8_t priority)</td></tr>
<tr class="memdesc:ab8074a9ac574f9b0d517bd4f9837b552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ab8074a9ac574f9b0d517bd4f9837b552">More...</a><br /></td></tr>
<tr class="separator:ab8074a9ac574f9b0d517bd4f9837b552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e486ef72d3db045a7a39c142ae79ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4e486ef72d3db045a7a39c142ae79ee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#aa4e486ef72d3db045a7a39c142ae79ee">Thread</a> (const char *name, T *object, void(T::*entry)(), void *stack, unsigned stackSize, uint8_t priority)</td></tr>
<tr class="memdesc:aa4e486ef72d3db045a7a39c142ae79ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to set the thread entry to a member function.  <a href="#aa4e486ef72d3db045a7a39c142ae79ee">More...</a><br /></td></tr>
<tr class="separator:aa4e486ef72d3db045a7a39c142ae79ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee51d426d8410b06d612c8097897ea0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#aee51d426d8410b06d612c8097897ea0b">Thread</a> (const char *name, <a class="el" href="group__ar__thread.html#gaba7d76c157b709dc09db85462cb75176">ar_thread_entry_t</a> entry, void *param, unsigned stackSize, uint8_t priority)</td></tr>
<tr class="memdesc:aee51d426d8410b06d612c8097897ea0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to dynamically allocate the stack.  <a href="#aee51d426d8410b06d612c8097897ea0b">More...</a><br /></td></tr>
<tr class="separator:aee51d426d8410b06d612c8097897ea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb3b195bb8bf7e68e5111bc52546d62"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aacb3b195bb8bf7e68e5111bc52546d62"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#aacb3b195bb8bf7e68e5111bc52546d62">Thread</a> (const char *name, T *object, void(T::*entry)(), unsigned stackSize, uint8_t priority)</td></tr>
<tr class="memdesc:aacb3b195bb8bf7e68e5111bc52546d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to set the thread entry to a member function, using a dynamic stack.  <a href="#aacb3b195bb8bf7e68e5111bc52546d62">More...</a><br /></td></tr>
<tr class="separator:aacb3b195bb8bf7e68e5111bc52546d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3c41095aa633bda03b9923e15f9bcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a3c41095aa633bda03b9923e15f9bcd"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a2a3c41095aa633bda03b9923e15f9bcd">~Thread</a> ()</td></tr>
<tr class="memdesc:a2a3c41095aa633bda03b9923e15f9bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a2a3c41095aa633bda03b9923e15f9bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c33ea11c2f892592c009d5f75116fad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c33ea11c2f892592c009d5f75116fad"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a2c33ea11c2f892592c009d5f75116fad">getName</a> () const </td></tr>
<tr class="memdesc:a2c33ea11c2f892592c009d5f75116fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's name. <br /></td></tr>
<tr class="separator:a2c33ea11c2f892592c009d5f75116fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread init and cleanup</div></td></tr>
<tr class="memitem:a268a3b32d7768740e3c7998e16fc4f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a268a3b32d7768740e3c7998e16fc4f23">init</a> (const char *name, <a class="el" href="group__ar__thread.html#gaba7d76c157b709dc09db85462cb75176">ar_thread_entry_t</a> entry, void *param, void *stack, unsigned stackSize, uint8_t priority)</td></tr>
<tr class="memdesc:a268a3b32d7768740e3c7998e16fc4f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base initialiser.  <a href="#a268a3b32d7768740e3c7998e16fc4f23">More...</a><br /></td></tr>
<tr class="separator:a268a3b32d7768740e3c7998e16fc4f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b333dd6d44caff232aaf0a26d0a9f58"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6b333dd6d44caff232aaf0a26d0a9f58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a6b333dd6d44caff232aaf0a26d0a9f58">init</a> (const char *name, T *object, void(T::*entry)(), void *stack, unsigned stackSize, uint8_t priority)</td></tr>
<tr class="memdesc:a6b333dd6d44caff232aaf0a26d0a9f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer to set the thread entry to a member function.  <a href="#a6b333dd6d44caff232aaf0a26d0a9f58">More...</a><br /></td></tr>
<tr class="separator:a6b333dd6d44caff232aaf0a26d0a9f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread priority</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Accessors for the thread's priority. </p>
</div></td></tr>
<tr class="memitem:affc27b6908ab94002b7512fb835f5cf2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affc27b6908ab94002b7512fb835f5cf2"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#affc27b6908ab94002b7512fb835f5cf2">getPriority</a> () const </td></tr>
<tr class="memdesc:affc27b6908ab94002b7512fb835f5cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread's current priority. <br /></td></tr>
<tr class="separator:affc27b6908ab94002b7512fb835f5cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305a4155b282edbc7c995b956770d277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a305a4155b282edbc7c995b956770d277">setPriority</a> (uint8_t priority)</td></tr>
<tr class="memdesc:a305a4155b282edbc7c995b956770d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the thread's priority.  <a href="#a305a4155b282edbc7c995b956770d277">More...</a><br /></td></tr>
<tr class="separator:a305a4155b282edbc7c995b956770d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Static members to get system-wide information. </p>
</div></td></tr>
<tr class="memitem:a3225bd5af1d2511e718597295a604e31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3225bd5af1d2511e718597295a604e31"></a>
static <a class="el" href="class_ar_1_1_thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a3225bd5af1d2511e718597295a604e31">getCurrent</a> ()</td></tr>
<tr class="memdesc:a3225bd5af1d2511e718597295a604e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently running thread object. <br /></td></tr>
<tr class="separator:a3225bd5af1d2511e718597295a604e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a99112d3407395ff4bd1384039f6d90c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a99112d3407395ff4bd1384039f6d90c3">threadEntry</a> (void *param)</td></tr>
<tr class="memdesc:a99112d3407395ff4bd1384039f6d90c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual thread entry point.  <a href="#a99112d3407395ff4bd1384039f6d90c3">More...</a><br /></td></tr>
<tr class="separator:a99112d3407395ff4bd1384039f6d90c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3e3791493e0a97b5ed96290e0caac54f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3e3791493e0a97b5ed96290e0caac54f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3e3791493e0a97b5ed96290e0caac54f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a3e3791493e0a97b5ed96290e0caac54f">member_thread_entry</a> (void *param)</td></tr>
<tr class="memdesc:a3e3791493e0a97b5ed96290e0caac54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to invoke a thread entry point that is a member function. <br /></td></tr>
<tr class="separator:a3e3791493e0a97b5ed96290e0caac54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1ba678da55a07a5aeeda2890efeebf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf1ba678da55a07a5aeeda2890efeebf"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#adf1ba678da55a07a5aeeda2890efeebf">thread_entry</a> (void *param)</td></tr>
<tr class="memdesc:adf1ba678da55a07a5aeeda2890efeebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static thread entry callback to invoke the virtual method. <br /></td></tr>
<tr class="separator:adf1ba678da55a07a5aeeda2890efeebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0d8ab03d04533fed05ba4175a631a98f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d8ab03d04533fed05ba4175a631a98f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a0d8ab03d04533fed05ba4175a631a98f">m_allocatedStack</a></td></tr>
<tr class="memdesc:a0d8ab03d04533fed05ba4175a631a98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically allocated stack. <br /></td></tr>
<tr class="separator:a0d8ab03d04533fed05ba4175a631a98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f5449c0e65cf9c5890562c3dfa5855"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f5449c0e65cf9c5890562c3dfa5855"></a>
<a class="el" href="group__ar__thread.html#gaba7d76c157b709dc09db85462cb75176">ar_thread_entry_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a19f5449c0e65cf9c5890562c3dfa5855">m_userEntry</a></td></tr>
<tr class="memdesc:a19f5449c0e65cf9c5890562c3dfa5855"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-specified thread entry point function. <br /></td></tr>
<tr class="separator:a19f5449c0e65cf9c5890562c3dfa5855"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread state</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp90c6d431dad6f9f20e0ff0247db6a205"></a>Control of and access to the thread state. </p>
</td></tr>
<tr class="memitem:a691d68343e01bae8e3b60d35efd4f1bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a691d68343e01bae8e3b60d35efd4f1bf">suspend</a> ()</td></tr>
<tr class="memdesc:a691d68343e01bae8e3b60d35efd4f1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put thread in suspended state.  <a href="#a691d68343e01bae8e3b60d35efd4f1bf">More...</a><br /></td></tr>
<tr class="separator:a691d68343e01bae8e3b60d35efd4f1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83520b6fe067f7fa57addca8b6943716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a83520b6fe067f7fa57addca8b6943716">resume</a> ()</td></tr>
<tr class="memdesc:a83520b6fe067f7fa57addca8b6943716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the thread eligible for execution.  <a href="#a83520b6fe067f7fa57addca8b6943716">More...</a><br /></td></tr>
<tr class="separator:a83520b6fe067f7fa57addca8b6943716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04c57b208296ab8161363a49a46d850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04c57b208296ab8161363a49a46d850"></a>
<a class="el" href="group__ar__thread.html#ga59b32dd975769447d8a9e8cdf39e1f56">ar_thread_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#aa04c57b208296ab8161363a49a46d850">getState</a> () const </td></tr>
<tr class="memdesc:aa04c57b208296ab8161363a49a46d850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current state of the thread. <br /></td></tr>
<tr class="separator:aa04c57b208296ab8161363a49a46d850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0014db107847869b311cf4deaac5585"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#aa0014db107847869b311cf4deaac5585">sleep</a> (unsigned milliseconds)</td></tr>
<tr class="memdesc:aa0014db107847869b311cf4deaac5585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep for a certain amount of time.  <a href="#aa0014db107847869b311cf4deaac5585">More...</a><br /></td></tr>
<tr class="separator:aa0014db107847869b311cf4deaac5585"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab8074a9ac574f9b0d517bd4f9837b552"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ar::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ar__thread.html#gaba7d76c157b709dc09db85462cb75176">ar_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">entry</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> entry point taking one parameter and returning void. </td></tr>
    <tr><td class="paramname">param</td><td>Arbitrary pointer-sized value passed as the single parameter to the thread entry point. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the start of the thread's stack. This should be the stack's bottom, not it's top. If this parameter is NULL, the stack will be dynamically allocated. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space allocated to the thread. This value is added to <em>stack</em> to get the initial top of stack address. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4e486ef72d3db045a7a39c142ae79ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ar::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to set the thread entry to a member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to an instance of class T upon which the <em>entry</em> member function will be invoked when the thread is started. </td></tr>
    <tr><td class="paramname">entry</td><td>Member function of class T that will be used as the thread's entry point. The member function must take no parameters and return void. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the start of the thread's stack. This should be the stack's bottom, not it's top. If this parameter is NULL, the stack will be dynamically allocated. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space allocated to the thread. This value is added to <em>stack</em> to get the initial top of stack address. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee51d426d8410b06d612c8097897ea0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ar::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ar__thread.html#gaba7d76c157b709dc09db85462cb75176">ar_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to dynamically allocate the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">entry</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> entry point taking one parameter and returning void. </td></tr>
    <tr><td class="paramname">param</td><td>Arbitrary pointer-sized value passed as the single parameter to the thread entry point. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space to allocate via <code>new</code> to the thread. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacb3b195bb8bf7e68e5111bc52546d62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ar::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to set the thread entry to a member function, using a dynamic stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to an instance of class T upon which the <em>entry</em> member function will be invoked when the thread is started. </td></tr>
    <tr><td class="paramname">entry</td><td>Member function of class T that will be used as the thread's entry point. The member function must take no parameters and return void. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space to allocate via <code>new</code> to the thread. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a268a3b32d7768740e3c7998e16fc4f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> Ar::Thread::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ar__thread.html#gaba7d76c157b709dc09db85462cb75176">ar_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base initialiser. </p>
<p>The thread is in suspended state when this method exits. To make it eligible for execution, call the <a class="el" href="class_ar_1_1_thread.html#a83520b6fe067f7fa57addca8b6943716" title="Make the thread eligible for execution. ">resume()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">entry</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> entry point taking one parameter and returning void. </td></tr>
    <tr><td class="paramname">param</td><td>Arbitrary pointer-sized value passed as the single parameter to the thread entry point. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the start of the thread's stack. This should be the stack's bottom, not it's top. If this parameter is NULL, the stack will be dynamically allocated. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space allocated to the thread. This value is added to <em>stack</em> to get the initial top of stack address. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a27e178199a575e82a814a560385d64f5" title="Operation was successful. ">kArSuccess</a></td><td>The thread was initialised without error. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a7910582dabf4bae4a35c182e77b2ce9d" title="Allocation failed. ">kArOutOfMemoryError</a></td><td>Failed to dynamically allocate the stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b333dd6d44caff232aaf0a26d0a9f58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> Ar::Thread::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer to set the thread entry to a member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to an instance of class T upon which the <em>entry</em> member function will be invoked when the thread is started. </td></tr>
    <tr><td class="paramname">entry</td><td>Member function of class T that will be used as the thread's entry point. The member function must take no parameters and return void. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the start of the thread's stack. This should be the stack's bottom, not it's top. If this parameter is NULL, the stack will be dynamically allocated. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space allocated to the thread. This value is added to <em>stack</em> to get the initial top of stack address. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a27e178199a575e82a814a560385d64f5" title="Operation was successful. ">kArSuccess</a></td><td>The thread was initialised without error. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a7910582dabf4bae4a35c182e77b2ce9d" title="Allocation failed. ">kArOutOfMemoryError</a></td><td>Failed to dynamically allocate the stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83520b6fe067f7fa57addca8b6943716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ar::Thread::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the thread eligible for execution. </p>
<p>If the thread being resumed has a higher priority than that of the current thread, the scheduler is called to immediately switch threads. In this case the thread being resumed will always become the new current thread. This is because the highest priority thread is always guaranteed to be running, meaning the calling thread was the previous highest priority thread.</p>
<p>Does not enter the scheduler if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running. Does nothing if the thread is already on the ready list.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Deal with all thread states properly. </dd></dl>

</div>
</div>
<a class="anchor" id="a305a4155b282edbc7c995b956770d277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> Ar::Thread::setPriority </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the thread's priority. </p>
<p>The scheduler is invoked after the priority is set so that the current thread can be changed to the one with the highest priority. The scheduler is invoked even if there is no new highest priority thread. In this case, control may switch to the next thread with the same priority, assuming there is one.</p>
<p>Does not enter the scheduler if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority level from 1 to 255, where lower numbers have a lower priority. Priority number 0 is not allowed because it is reserved for the idle thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kInvalidPriorityError</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0014db107847869b311cf4deaac5585"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ar::Thread::sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the current thread to sleep for a certain amount of time. </p>
<p>Does nothing if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticks</td><td>The number of milliseconds to sleep the calling thread. A sleep time of 0 is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a691d68343e01bae8e3b60d35efd4f1bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ar::Thread::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put thread in suspended state. </p>
<p>If this method is called from the current thread then the scheduler is entered immediately after putting the thread on the suspended list. Calling <a class="el" href="class_ar_1_1_thread.html#a691d68343e01bae8e3b60d35efd4f1bf" title="Put thread in suspended state. ">suspend()</a> on another thread will not cause the scheduler to switch threads.</p>
<p>Does not enter the scheduler if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running. Does nothing if the thread is already suspended.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Deal with all thread states properly. </dd></dl>

</div>
</div>
<a class="anchor" id="a99112d3407395ff4bd1384039f6d90c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ar::Thread::threadEntry </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual thread entry point. </p>
<p>This is the method that subclasses should override. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ar.html">Ar</a></li><li class="navelem"><a class="el" href="class_ar_1_1_thread.html">Thread</a></li>
    <li class="footer">Generated on Thu Jan 1 2015 19:02:13 for Argon RTOS by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
